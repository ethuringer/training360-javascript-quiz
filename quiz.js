export const quiz = [
    // HTML haladó
    {
        header1:    'HTML haladó',
        header2:    'Haladó HTML 1 / 2',
        question:   'Mikor jelent meg a HTML szabvány 1.0 verziója?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['1993',
                    '2013',
                    '2003',
                    '1985'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     ''
    },
    {
        header1:    'HTML haladó',
        header2:    'Haladó HTML 2 / 2',
        question:   'Melyik volt a \'90-es évek közepén a legelterjedtebb böngésző?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Netscape Navigator',
                    'Internet Explorer',
                    'Mozilla Firefox',
                    'Google Chrome'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     ''
    },
    {
        header1:    'HTML haladó',
        header2:    'Szemantikus elemek 1 / 5',
        question:   'Melyik NEM szemantikus elem az alábbiak közül?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['<div></div>',
                    '<nav></nav>',
                    '<header></header>',
                    '<footer></footer>'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     ''
    },
    {
        header1:    'HTML haladó',
        header2:    'Szemantikus elemek 2 / 5',
        question:   'Tipikusan milyen célra használjuk a &nbsp; < nav > < / nav > &nbsp; elemet?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['A navigáció megjelenítésére.',
                    'Felugró ablakok megjelenítésére.',
                    'Nem létezik ilyen szabványos HTML elem.',
                    'Az adóbevallás benyújtására.'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     ''
    },
    {
        header1:    'HTML haladó',
        header2:    'Szemantikus elemek 3 / 5',
        question:   'Hova érdemes elhelyezni a szemantikus szemlélet alapján a fő menüpontokat az oldalon?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['A <nav></nav> elembe.',
                    'A <header></header> elembe.',
                    'Egy <iframe></iframe> elembe.',
                    'Nem szükséges elhelyezni őket, a felhasználó is ki tudja találni az oldalak címét.'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     ''
    },
    {
        header1:    'HTML haladó',
        header2:    'Szemantikus elemek 4 / 5',
        question:   'Milyen célt szolgál az &nbsp; < iframe > < / iframe > &nbsp; elem?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Egy másik weboldalt jelenít meg egy keretben.',
                    'Animációk megjelenítését biztosítja.',
                    'Intelligens segéd beszúrását teszi lehetővé.',
                    'Az Apple szolgáltatásaihoz biztosít hozzáférést, mint például az iCloud vagy iMessages.'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     ''
    },
    {
        header1:    'HTML haladó',
        header2:    'Szemantikus elemek 5 / 5',
        question:   'Hogyan tudsz készíteni olyan &nbsp; < details > < / details > &nbsp; elemet, amely alapértelmezésben már nyitott, azaz látszik a tartalma?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['<details open></details>',
                    '<details show></details>',
                    '<details slide-down></details>',
                    '<details></details>'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     ''
    },
    {
        header1:    'HTML haladó',
        header2:    'SEO 1 / 4',
        question:   'Melyik NEM SEO meta tag?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['<meta name="viewport" content="width=device-width, initial-scale=1.0" />',
                    '<meta name="title" content="Egymillió dollár értékű repülő mókust csempésztek ki Floridából" />',
                    '<meta name="description" content="Az elfogott vadorzók védett teknősökkel és aligátorokkal is kereskedtek." />',
                    '<meta name="robots" content="all">'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     ''
    },
    {
        header1:    'HTML haladó',
        header2:    'SEO 2 / 4',
        question:   'Mi az ideális szósűrűség?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['2-3%',
                    '20-30%',
                    '85%',
                    '0.1%'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     ''
    },
    {
        header1:    'HTML haladó',
        header2:    'SEO 3 / 4',
        question:   'Hogyan befolyásolja a SEO-t az oldal sebessége?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['A lassú oldalakat elhagyják a felhasználók mielőtt betöltődnének.',
                    'Nem befolyásolja.',
                    'Ha eléggé lassú az oldal, az nyugtatólag hat a látogatókra.',
                    'A lassú oldalakat előrébb sorolja a Google keresője.'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     ''
    },
    {
        header1:    'HTML haladó',
        header2:    'SEO 4 / 4',
        question:   'Mire szolgálnak az OpenGraph meta elemek?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['A közösségi oldalakon való megjelenést lehet velük beállítani.',
                    'Térképek megjelenítését teszik lehetővé.',
                    'A nyitott társadalom kezdeményezés támogatását biztosítják.',
                    'Bonyolult grafikai elemeket és ábrákat lehet velük megjeleníteni.'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     ''
    },
    // 1. JS - Változók
    {
        header1:    '1. JavaScript haladó - Változók, függvények és tömbök',
        header2:    'Változók 1 / 3',
        question:   'Melyik kulcsszóval létrehozott változók esetében van hoisting?<br><br>Válaszd ki az ÖSSZES megfelelő választ!',
        options:    ['var',
                    'let',
                    'const',
                    'Egyiknél sincs'],
        results:    'A, B, C',
        result:     123,
        boolres:    [true, true, true, false],
        answer:     'Mind a háromnál van hoisting, a különbség annyi,<br>hogy var esetében a változó inicializálódik is undefined kezdőértékkel.'
    },
    {
        header1:    '1. JavaScript haladó - Változók, függvények és tömbök',
        header2:    'Változók 2 / 3',
        question:   'Melyik kulcsszóval létrehozott változó esetében nem megengedett a reassignment (újra értékadás)?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['var',
                    'let',
                    'const',
                    'Mindegyiknél megengedett'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'A const immutable bindingot hoz létre, nem lehet újra értéket adni a változónak.'
    },
    {
        header1:    '1. JavaScript haladó - Változók, függvények és tömbök',
        header2:    'Változók 3 / 3',
        question:   'Melyik állítások igazak a let és const kulcsszóval deklarált változókra?<br><br>Válaszd ki az ÖSSZES megfelelő választ!',
        options:    ['nem lehet őket újradeklarálni',
                    'blokk hatókörűek',
                    'inicializálás előtt nem elérhetőek',
                    'nem lehet új értéket adni nekik'],
        results:    'A, B, C',
        result:     123,
        boolres:    [true, true, true, false],
        answer:     'Egyedül a const kulcsszóval létrehozott változóknál nem engedélyezett a reassignment (új értéket adni az "=" operátorral).'
    },
    // 1. JS - Függvények
    {
        header1:    '1. JavaScript haladó - Változók, függvények és tömbök',
        header2:    'Függvények 1 / 3',
        question:   'Hogy hívják azt a függvényt, amit más függvénynek adunk át paraméterként?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['callback function',
                    'arrow function',
                    'higher order function',
                    'IIFE'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'Azt a függvényt, amelyet másik függvénynek adunk át paraméterként, egyezményesen callback functionnek hívjuk.<br>Azt pedig, amelyik ezzel dolgozik, higher order functionnek.<br>Az arrow function  egy újabb szintaxis function expression létrehozására, illetve rendelkezik néhány speciális tulajdonsággal.<br>Az IIFE (Immediately Invoked Function Expression - Azonnal Meghívott Függvény Kifejezés) segítségével olyan függvényeket tudunk írni, ami a definiálásakor rögtön le is fut.'
    },
    {
        header1:    '1. JavaScript haladó - Változók, függvények és tömbök',
        header2:    'Függvények 2 / 3',
        question:   'Melyik állítások helyesek a JavaScript memóriakezelésével kapcsolatban?<br><br>Válaszd ki az ÖSSZES megfelelő választ!',
        options:    ['A Heap rendezetlen memóriaterület',
                    'A Stackben tárolódnak az objektumok',
                    'A Heapben tárolódnak a primitívek',
                    'A JavaScriptben automatikus a szemétgyűjtés'],
        results:    'A, D',
        result:     14,
        boolres:    [true, false, false, true],
        answer:     'A Heap egy rendezetlen nagyméretű memóriaterület, ahol az objektumok tárolódnak.<br>A Stack mérete sokkal korlátozottabb, a primitívek itt tárolódnak.<br>A JavaScriptben a szemétgyűjtés automatikus. A Garbage Collector munkájába nem tudunk közvetlenül beleavatkozni.'
    },

    {
        header1:    '1. JavaScript haladó - Változók, függvények és tömbök',
        header2:    'Függvények 3 / 3',
        question:   'Melyik állítás igaz az arrow functionre?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['nem bindolja a this-t',
                    'a paramétert/paramétereket  kötelező zárójelbe tenni',
                    'objektum nem szerepelhet visszatérési értékként',
                    'mindig használnunk kell a return utasítást a függvényen belül'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'Az arrow function nem köti a saját this-t, ezért ne használjuk objektum metódusaként.<br>Amennyiben csak egy darab paraméter van, azt nem kötelező zárójelbe tenni.<br>Arrow function esetében, akárcsak hagyományos függvényeknél, bármilyen típusú adat lehet visszatérési érték.<br>Return utasítást nem kötelező használni, lehet implicit visszatérési értékünk.'
    },
    // 1. JS - Tömbök
    {
        header1:    '1. JavaScript haladó - Változók, függvények és tömbök',
        header2:    'Tömbök 1 / 3',
        question:   'Melyik metódus módosítja az eredeti tömböt?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['forEach()',
                    'map()',
                    'reduce()',
                    'egyik sem'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'A fenti metódusok az eredeti tömböt nem módosítják, azaz nem mutálják, ellenben a push(), pop(), shift(), unshift() metódusok például igen.<br>Érdemes mindig olyan megoldásokra törekednünk, amelyek az eredeti tömböt nem módosítják.'
    },
    {
        header1:    '1. JavaScript haladó - Változók, függvények és tömbök',
        header2:    'Tömbök 2 / 3',
        question:   'Az alábbi metódushívásnak mi lesz a visszatérési értéke?<br><br>&emsp; [0, null, undefined, \'\'].filter(item => item)<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['[ ]',
                    '[0]',
                    '[0, null, undefined, \'\']',
                    '[null, \'\']'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'Üres tömböt fogok visszakapni, mert feltételvizsgálatnál mind a 0, a null, az undefined, és az üres string is false-t ad vissza.'
    },
    {
        header1:    '1. JavaScript haladó - Változók, függvények és tömbök',
        header2:    'Tömbök 3 / 3',
        question:   'Mi lesz a value értéke? A 0 paraméter csak a kezdőértéket állítja be.<br><br>&emsp; const value = [{v: 1}, {v: 2}, {v: 3}].reduce(<br>&emsp; &emsp; (accumulator, currentValue) => accumulator + currentValue.v, 0)<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['1',
                    '2',
                    '3',
                    '6'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'A reduce jelen esetben nem csinál mást, mint hogy összeadja a tömbben lévő objektumok v tulajdonságainak az értékét.<br>A kezdőértéket 0-ra állítjuk, és az accumulator-ban ehhez folyamatosan hozzáadjuk a soron következő objektum v tulajdonságának értékét.'
    },
    // 2. JS - Szövegek
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Szövegek 1 / 3',
        question:   'Mi lesz a b értéke a függvényen belül?<br><br>&emsp; function restParameter(a, ...b) {<br>&emsp; &emsp; //...<br>&emsp; }<br><br>&emsp; restParameter(1, 2, 3, 4, 5);<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['2',
                    '[1]',
                    '[2, 3, 4, 5]',
                    '[1, 2, 3, 4, 5]'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'Jelen esetben rest paramétert használtunk.<br>Az a értéke 1 lesz, míg a b értéke az összes többi paraméter tömbösítve, tehát: [2, 3, 4, 5].'
    },

    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Szövegek 2 / 3',
        question:   'Az alábbi kód lefutása után mi lesz a konzolon?<br><br>&emsp; const age = { age: 33 }<br>&emsp; const name = { firstname: \'John\', lastname: \'Doe\'}<br>&emsp; console.log({...name, ...age })<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['{ firstname: \'John\', lastname: \'Doe\', age: 33 }',
                    '[ firstname: \'John\', lastname: \'Doe\', { age: 33 } ]',
                    '[ { firstname: \'John\', lastname: \'Doe\'}, { age: 33 } ]',
                    '[ \'John\', \'Doe\', 33 ]'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'Két objektumot fűztünk össze.<br>A kimeneten egy olyan új objektum lesz, amely mind a kettő tulajdonságait tartalmazza.'
    },
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Szövegek 3 / 3',
        question:   'Melyik kifejezés NEM lenne helyes egy konzolra való kiíráskor, amennyiben a kiinduló kód a következő:<br><br>&emsp; const a = 10<br>&emsp; const b = 20<br>&emsp; const sum = (firstNumber, secondNumber) => firstNumber + secondNumber<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['érték: ${a + b}',
                    'érték: ${sum(a, b)}',
                    'érték: ${sum(firstNumber, secondNumber)}',
                    'érték: ${sum(10, 20)}'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'A firstNumber és a secondNumber a paraméterek nevei, csak függvényen belül használhatom őket.<br>A függvényen kívül nem léteznek, tehát itt ReferenceError-t kapunk.'
    },
    // 2. JS - Számok, és a Math objektum
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Számok és a Math objektum 1 / 3',
        question:   'Mi lesz a két visszatérési érték az alábbi esetekben?<br><br>&emsp; isNaN(\'value\')<br>&emsp; Number.isNaN(\'value\')<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['true, true',
                    'true, false',
                    'false, true',
                    'false, false'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Míg a globális isNaN() loose equality-t használ, addig a Number.isNaN() strict equality-t, tehát a típust is vizsgálja, nem csak az értéket.'
    },
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Számok és a Math objektum 2 / 3',
        question:   'Az alábbiak közül milyen számrendszerbeli számokkal tudunk dolgozni JavaScriptben?<br><br>Válaszd ki az ÖSSZES megfelelő választ!',
        options:    ['bináris (2)',
                    'oktális (8)',
                    'decimális (10)',
                    'hexadecimális (16)'],
        results:    'A, B, C, D',
        result:     1234,
        boolres:    [true, true, true, true],
        answer:     'Mindegyik helyes megoldás volt.<br>Alaphelyzetben 10-es számrendszerbeli számokkal dolgozunk, azonban 0b, 0o, 0x előtagokkal megadott számok automatikusan a bináris, oktális, és hexadecimális számrendszerbe fognak tartozni.'
    },
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Számok és a Math objektum 3 / 3',
        question:   'Maximum mekkora értéket vehetnek fel a BigInt típusú számok?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['A Number.MAX_SAFE_INTEGER segítségével lekérdezhető',
                    'A Number.MAX_VALUE segítségével lekérdezhető',
                    'Nincs elvi korlátja, maximum a memória mennyisége szab neki határt',
                    'Pontosan 10 a századikon a legnagyobb ábrázolható érték'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'A BigInt típusnak nincs a mérete lekorlátozva. Amíg van elég memória, bármekkora értéket felvehet.'
    },
    // 2. JS - Adatok átstrukturálása
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Adatok átstrukturálása 1 / 3',
        question:   'Mi lesz az <i>n</i>, az <i>s</i> és a <i>k</i> változók értéke?<br><br>&emsp; const pet = {<br>&emsp; &emsp; name: \'Szetti\',<br>&emsp; &emsp; species: \'dog\',<br>&emsp; &emsp; age: 3<br>&emsp; }<br><br>&emsp; const { name: n, species: s, kor: k = 10 } = pet;<br><br>Válaszd ki az EGYETLEN megfelelő választ!<br>',
        options:    ['\'Szetti\', \'dog\', 3',
                    '\'Szetti\', \'dog\', 10',
                    '\'Szetti\', \'dog\', undefined',
                    'Hibás a kód'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'A pet objektum nem rendelkezik kor tulajdonsággal, így a megadott default value, azaz 10 lesz az értéke.'
    },
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Adatok átstrukturálása 2 / 3',
        question:   'Mi lesz az <i>a</i> és a <i>d</i> változók értéke?<br><br>&emsp; const arr = [\'one\', \'two\', \'three\', \'four\'];<br>&emsp; const [a, , , d] = arr;<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['\'one\', \'two\'',
                    '\'one\', \'three\'',
                    '\'one\', \'four\'',
                    'Hibás a kód'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'Az <i>a</i> értéke a tömb első elemének az értékét veszi fel, majd két elemet kihagyunk, a <i>d</i> a negyedik elem, azaz a 3. indexű elem értékét kapja meg, ami \'four\'.'
    },
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Adatok átstrukturálása 3 / 3',
        question:   'Mi lesz a pet objektum name tulajdonságának az értéke a kód lefutása után?<br><br>&emsp; const pet = {<br>&emsp; &emsp; name: \'Szetti\',<br>&emsp; &emsp; species: \'dog\',<br>&emsp; &emsp; age: 3<br>&emsp; }<br><br>&emsp; let { name } = pet<br>&emsp; name = \'Bogyó\'<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Szetti',
                    'Bogyó',
                    'undefined',
                    'Hibás a kód'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'A destructuring után a referencia elveszik. A name egy egyszerű primitív lesz. Ha azt módosítjuk, az objektum tulajdonsága nem fog módosulni.'
    },
    // 2. JS - Dátumok
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Dátumok 1 / 3',
        question:   'Az alábbi kód esetében a date változónál a 2020-as év melyik hónapja és napja van beállítva?<br><br>&emsp; const date = new Date(2020, 1, 1)<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['január 1.',
                    'február 1.',
                    'január 2.',
                    'február 2.'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Mivel a hónapok 0-tól kezdődően számozódnak (mint a tömbindexek), ezért az 1 a február hónapot jelöli.<br>A második egyes a nap száma, az 1-től számozódik.'
    },
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Dátumok 2 / 3',
        question:   'Mi lesz a konzolon az alábbi kód lefutása után?<br><br>&emsp; const date = new Date(2020, 0, 1)<br>&emsp; date.setDate(32)<br>&emsp; console.log(date)<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Jan 01 2020',
                    'Jan 32 2020',
                    'Feb 01 2020',
                    'RangeError: Invalid argument.'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'Trükkös volt. A január 1-et módosítjuk. A napszámot 32-re átállítottam.<br>Ugyan januárban nincs 32. nap, azonban ez nem probléma, mert ilyen esetben automatikusan ugrik a következő dátumra.<br>Tehát januárban 31 nap van, plusz egy, az február 1.'
    },
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Dátumok 3 / 3',
        question:   'Mi lesz a konzolon az alábbi kód lefutása után?<br><br>&emsp; const date = Date.UTC(2020, 0, 1)<br>&emsp; console.log(date)<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Egy date object UTC alapú értékkel',
                    'Egy date object lokális idő alapú értékkel',
                    '1970. január 1. óta eltelt idő ezredmásodpercben',
                    'Error'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'A UTC() metódus az 1970. január 1. óta eltelt időt adja vissza ezredmásodpercben.'
    },
    // 3. JS - Modulok és kivételek
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'Egyéb újdonságok 1 / 3',
        question:   'Melyik adatszerkezetben nem lehetséges duplikált elemek elhelyezése?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Array',
                    'Map',
                    'Set',
                    'WeakMap'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     '<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank">Dokumentáció</a>'
    },
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'Egyéb újdonságok 2 / 3',
        question:   'Melyik metódus nem érhető el WeakMap esetében?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['get',
                    'set',
                    'delete',
                    'clear'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     '<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" target="_blank">Dokumentáció</a><br>A WeakMap csak get(), set(), has(), delete() metódusokkal rendelkezik.'
    },
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'Egyéb újdonságok 3 / 3',
        question:   'Mi lesz a konzolon?<br><br>&emsp; const id = Symbol(\'id\');<br>&emsp; const person = {<br>&emsp; &emsp; [id]: 1,<br>&emsp; &emsp; firstName: \'John\',<br>&emsp; &emsp; lastName: \'Doe\'<br>&emsp; }<br>&emsp; console.log(person.id)<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['1',
                    'undefined',
                    'Symbol(id): 1',
                    'Error'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'A person id tulajdonságát a pont operátorral nem érjük el.<br>Használjuk a getOwnPropertySymbols() metódust a Symbol property-k elérésére, vagy itt akár a person[id]-t.'
    },
    // 3. JS - Web storage-ok
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'Web storage-ok 1 / 3',
        question:   'Melyik storage típus tartalma törlődik a böngésző bezárásakor?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['cookie',
                    'sessionStorage',
                    'localStorage',
                    'egyiké sem'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'A cookie és a localStorage megőrzi a benne tárolt adatokat, amíg mi vagy a user ki nem törli őket.<br>Ezzel szemben a sessionStorage, ahogy a neve is mondja, csak az adott sessionre, azaz munkamenetre őrzi meg a tartalmat.'
    },
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'Web storage-ok 2 / 3',
        question:   'Mekkora lehet egy süti maximális mérete (általában)?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['4KB',
                    '5MB',
                    '25MB',
                    'Nincs korlátozva'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     '<a href="https://tools.ietf.org/html/rfc6265#section-4.1.1" target="_blank">Dokumentáció</a><br>RFC szabvány által van meghatározva.'
    },
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'Web storage-ok 3 / 3',
        question:   'Hol tároljuk a titkosítatlan jelszavakat?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['cookie-ban',
                    'localStorage-ben',
                    'sessionStorage-ben',
                    'Sehol'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'A jelszavakat mindig sózzuk, titkosítjuk!'
    },
    // 3. JS - A JavaScript modul rendszere
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'A JavaScript modul rendszere 1 / 3',
        question:   'Maximum hány darab export utasítás lehet egy file-ban?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['1',
                    '2',
                    'Csak export default lehet, sima export nem',
                    'Akármennyi'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'Az exportok száma nincs bekorlátozva a szabvány alapján.'
    },
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'A JavaScript modul rendszere 2 / 3',
        question:   'Maximum hány darab export default utasítás lehet egy file-ban?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['1',
                    '2',
                    '32',
                    'Akármennyi'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'Míg named export-ból akármennyi lehet, defaultból csak egy darab.<br>Akkor használjuk ha az adott file csak egy class-t, object-et stb. tartalmaz.'
    },
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'A JavaScript modul rendszere 3 / 3',
        question:   'Lehetséges az import utasítást feltételhez kötni? Pl.:<br><br>&emsp; if (condition) {<br>&emsp; &emsp; import { myModule } from \'./my.js\';<br>&emsp; }<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Igen, bármikor lehet',
                    'Nem lehet',
                    'Csak import as utasítás lehet feltételnél',
                    'Csak default export esetében lehet feltételhez kötött import'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Minden importnak a file elején kell szerepelnie. Tehát nem lehet ilyen módon feltételhez kötni.'
    },
    // 3. JS - A Regexp objektum
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'A Regexp objektum 1 / 3',
        question:   'Melyik Regexp flag segítségével tudom case insensitive-en vizsgálni az illeszkedést?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['g',
                    'm',
                    'i',
                    'Nincs rá lehetőség'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'Az i az ignorecase kapcsoló. Nem fog különbséget tenni a kis- és nagybetűk között.<br>A g flaggel globális keresést, az m-mel a többsoros keresést tudjuk bekapcsolni.'
    },
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'A Regexp objektum 2 / 3',
        question:   'Adott az alábbi reguláris kifejezés: ([A-Z])\\w+/g<br>Hány találatunk lenne illeszkedés vizsgálatakor az alábbi mondat esetében?:<br>“RegExr was created By trining360.com.”<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['1',
                    '2',
                    '3',
                    '4'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Kettő darab nagybetűvel kezdődő szó van a mondatban, ezekre fog illeszkedni a kifejezés.<br>[A-Z]: legyen egy angol nagybetű <br>\w: utána az alábbiak közül: a-z, A-Z, 0-9, _<br>+: egy vagy több az előző karakterből<br>/g: globálisan keresünk'
    },
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'A Regexp objektum 3 / 3',
        question:   'Melyik stringre fog illeszkedni az alábbi minta?<br><br>&emsp; /^(\\d{3} ){2}\\d{3}$/<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['\'123456789\'',
                    '\'123 456 789\'',
                    '123',
                    '456 789'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'A leckék során már egyszer előkerült ez a példa. A TAJ számot validáltuk.<br>^(\\d{3} ){2}: kezdődjön a string három darab számmal, ami után egy szóköz van<br>{2}: az előbbiből legyen 2<br>\\d{3}$: majd a végén legyen még 3 darab számjegy egymás után'
    },
    // 3. JS - Kivételkezelés
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'Kivételkezelés 1 / 3',
        question:   'Egy try blokk után mennyi catch blokk lehet?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['csak egy',
                    'maximum 12 darab',
                    'akármennyi',
                    'ha van utána finally, akkor akármennyi'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'JavaScriptben nem támogatott a multiple catch ág.<br>Ha több kivételt szeretnénk lekezelni, azt egy catch blokkon belül kell megtennünk.'
    },
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'Kivételkezelés 2 / 3',
        question:   'Milyen estben fut le finally ágban lévő kód?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['csak akkor, ha a try blokkban nem volt hiba',
                    'csak akkor, ha a try blokkban hiba volt, ilyenkor a catch blokk kódja után',
                    'csak akkor, ha a try blokkban hiba volt, ilyenkor a catch blokk kódja előtt',
                    'mindig'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'Mindig. A finally mindig lefut, akár volt hiba, akár nem.'
    },
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'Kivételkezelés 3 / 3',
        question:   'Milyen típusú hibát fogok kapni az alábbi kód esetében? (Csak ennyi a file tartalma!)<br><br>&emsp; try {<br>&emsp; &emsp; powFunction();<br>&emsp; } catch(error){<br>&emsp; &emsp; console.log(error.name);<br>&emsp; }<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['ReferenceError',
                    'SyntaxError',
                    'TypeError',
                    'RangeError'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'ReferenceError, mert nem létezik a powFunction nevű függvény.'
    },
    // 4. JS - Promise
    {
        header1:    '4. JavaScript haladó - Aszinkron programozás',
        header2:    'Promise 1 / 3',
        question:   'Az alábbiak közül melyik nem lehet egy Promise állapota?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['rejected',
                    'resolved',
                    'pending',
                    'canceled'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'A promise az alábbi állapotokkal rendelkezhet: pending, fulfilled, rejected, illetve settled (ha fulfilled vagy rejected, de nem pending).'
    },
    {
        header1:    '4. JavaScript haladó - Aszinkron programozás',
        header2:    'Promise 2 / 3',
        question:   'Mi lesz az alábbi kód lefutása után a konzolon?<br><br>&emsp; Promise.resolve(\'ok\')<br>&emsp; &emsp; .then(data => {<br>&emsp; &emsp; &emsp; return data.toUpperCase()<br>&emsp; &emsp; })<br>&emsp; &emsp; .then(data => {<br>&emsp; &emsp; &emsp; console.log(data)<br>&emsp; &emsp; &emsp; return data<br>&emsp; &emsp; })<br>&emsp; &emsp; .then(console.log)<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['ok',
                    'OK',
                    'ok, OK',
                    'OK, OK'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'Az első then-ben nagybetűssé alakítjuk az ok stringet.<br>A második then-ben ezt kiírjuk a konzolra és továbbadjuk.<br>A harmadik then callback function-je a console.log, ami automatikusan megkapja a stringet, tehát felesleges ezt írnunk: data => console.log(data)'
    },
    {
        header1:    '4. JavaScript haladó - Aszinkron programozás',
        header2:    'Promise 3 / 3',
        question:   'Mit hivatott felváltani a fetch API?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['a setTimeout()-ot',
                    'az XMLHttpRequestet',
                    'a callback-eket',
                    'a Promise-okat'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     '<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank">Dokumentáció</a>'
    },
    // 4. JS - Aszinkron programozás
    {
        header1:    '4. JavaScript haladó - Aszinkron programozás',
        header2:    'Aszinkron programozás 1 / 3',
        question:   'Mire tipikus példa az alábbi kód?<br><br>&emsp; one(1, function () {<br>&emsp; &emsp; two(2, function () {<br>&emsp; &emsp; &emsp; three(3, function () {<br>&emsp; &emsp; &emsp; &emsp; four(4, function () {<br>&emsp; &emsp; &emsp; &emsp; &emsp; five(5)<br>&emsp; &emsp; &emsp; &emsp; })<br>&emsp; &emsp; &emsp; })<br>&emsp; &emsp; })<br>&emsp; })<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['async programming',
                    'callback hell',
                    'timer',
                    'loopback'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Függvény, ami paraméterként kap egy függvényt, ami paraméterként kap egy függvényt, ami...<br>Callback hell. Callbacknek hívjuk a függvényt, amit paraméterként adunk át másik függvénynek.<br>Ebből van sok egymásba ágyazva. Pokoli nehéz átlátni egy idő után.'
    },
    {
        header1:    '4. JavaScript haladó - Aszinkron programozás',
        header2:    'Aszinkron programozás 2 / 3',
        question:   'Mi lesz a konzolon az alábbi kód esetén, ha rákattintok a DOM-ban lévő click-me class-ű gombra?<br><br>&emsp; const btn = document.querySelector(\'.click-me\');<br><br>&emsp; btn.addEventListener(\'click\', () => {<br>&emsp; &emsp; console.log(\'Listener\');<br><br>&emsp; &emsp; setTimeout(console.log, 0, \'Timer\')<br><br>&emsp; &emsp; Promise<br>&emsp; &emsp; &emsp; .resolve(\'Promise1\')<br>&emsp; &emsp; &emsp; .then(console.log)<br><br>&emsp; &emsp; Promise<br>&emsp; &emsp; &emsp; .resolve(\'Promise2\')<br>&emsp; &emsp; &emsp; .then(console.log)<br>&emsp; })<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Promise1, Promise2, Listener, Timer',
                    'Listener, Timer, Promise1, Promise2',
                    'Listener, Promise1, Promise2, Timer',
                    'Timer, Promise1, Promise2, Listener'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'Először lefut a szinkron kód, utána a Microtask queue-ben lévő 2 Promise, tehát Promise1, Promise2, és a végén a Task Queue-ben lévő timeout callbackje.'
    },
    {
        header1:    '4. JavaScript haladó - Aszinkron programozás',
        header2:    'Aszinkron programozás 3 / 3',
        question:   'Mi lesz a kimeneten?<br><br>&emsp; console.log(\'start\');<br>&emsp; setTimeout(console.log, 1000, \'1000\');<br>&emsp; console.log(\'end\');<br>&emsp; setTimeout(console.log, 0, \'0\');<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['start, 1000, end, 0',
                    'start, end, 1000, 0',
                    'start, end, 0, 1000',
                    '0, 1000, start, end'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'Először sorrendben a 2 szinkron utasítás: start, end<br>Utána a két callback, jelen esetben elsőnek a 0, mert itt sokkal kisebb volt a delay (hacsak az előtte lévő console.log(‘end’) művelet lefuttatása nem tart egy másodpercig, és nem fog), mint az 1000-es párjánál, ami a legvégén fog csak lefutni.'
    },
    // 4. JS - Generátorok
    {
        header1:    '4. JavaScript haladó - Aszinkron programozás',
        header2:    'Generátorok 1 / 2',
        question:   'Mi a next() metódus visszatérési értéke?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['egy value, azaz valamilyen érték',
                    'egy boolean, ami true, ha a függvény befejezett, egyébként false',
                    'egy object, ami done és value tulajdonságokat tartalmaz',
                    'egy Promise'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'A visszatérési érték egy olyan object, ahol a done property értéke true, ha a függvény befejezett, egyébként false, a value property értéke pedig a yield utáni érték.'
    },
    {
        header1:    '4. JavaScript haladó - Aszinkron programozás',
        header2:    'Generátorok 2 / 2',
        question:   'Válaszd ki az igaz állításokat!<br><br>Válaszd ki az ÖSSZES megfelelő választ!',
        options:    ['Meg lehet adni generátor függvényen belül a yield után értéknek egy másik generátor függvény hívás értékét',
                    'A hibakezelést mindig a generátor függvényen kívül kell megvalósítanunk, az nem tartalmazhat try catch blokkot',
                    'Generátor függvényen belül a return használata esetén mindig hibát kapunk',
                    'Generátor függvényeket kombinálhatunk Promise-okkal'],
        results:    'A, D',
        result:     14,
        boolres:    [true, false, false, true],
        answer:     'Meg lehet adni generátor függvényen belül a yield után értéknek egy másik generátor függvény hívás értékét: igaz, hiszen a yield* pont erre szolgál.<br>A hibakezelést mindig a generátor függvényen kívül kell megvalósítanunk, az nem tartalmazhat try catch blokkot: hamis, példát is láthattunk a használatára.<br>Generátor függvényen belül a return használata esetén mindig hibát kapunk: nem kapunk hibát, egyszerűen next() metódushívásnál nem lesz ott return utáni érték.<br>Generátor függvényeket kombinálhatunk Promise-okkal: természetesen, erre is láthattunk példát. Több fetch kérést küldtünk el a kettő kombinálásával.'
    },
    // 4. JS - Aszinkron függvények
    {
        header1:    '4. JavaScript haladó - Aszinkron programozás',
        header2:    'Aszinkron függvények 1 / 2',
        question:   'Mi lesz az async function visszatérési értéke?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['amit megadunk return után',
                    'mindig egy Promise',
                    'egy Iterable',
                    'egy Iterator'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Az aszinkron függvények visszatérési értéke mindig egy Promise.<br>Az async await valójában csak egy egyszerűsített szintaxis a new Promise, then... részekre.'
    },
    {
        header1:    '4. JavaScript haladó - Aszinkron programozás',
        header2:    'Aszinkron függvények 2 / 2',
        question:   'Mi lesz a konzolon az alábbi kód lefutása után, ha minden async hívás is véget ért?<br><br>&emsp; const thenable = {<br>&emsp; &emsp; age: 30,<br>&emsp; &emsp; then(resolve, reject) {<br>&emsp; &emsp; &emsp; setTimeout(() => resolve(this.age * 2), 1000)<br>&emsp; &emsp; }<br>&emsp; };<br><br>&emsp; async function f() {<br>&emsp; &emsp; const result = await thenable;<br>&emsp; &emsp; console.log(result)<br>&emsp; }<br><br>&emsp; f();<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Error',
                    '60',
                    'Promise',
                    'ƒ Function() { [native code] }'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Az await után megadtunk egy thenable objectet, tehát egy olyan objektumot, aminek van then metódusa.<br>Tehát az await után a thenable object then metódusa hívódik meg. Ott egy setTimeout van, ami egy másodperc múlva meghívja a resolve-ot, paraméterként átadva neki az age property értékének a dupláját, a 2 * 30-at. Az f függvényen belül ezt az értéket fogjuk kiírni.'
    },
    // 5. JS - This
    {
        header1:    '5. JavaScript haladó - Objektum Orientált Programozás',
        header2:    'This 1 / 4',
        question:   'Mi lesz a this értéke a függvényen belül, amikor meghívjuk? (A globális környezetben vagyunk)<br><br>&emsp; \'use strict\';<br><br>&emsp; function myFunction() {<br>&emsp; &emsp; return this;<br>&emsp; }<br><br>&emsp; myFunction();<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['A function',
                    'A Window object',
                    'null',
                    'undefined'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'Strict módban, globális kódban elhelyezett függvény esetében mindig undefined.'
    },
    {
        header1:    '5. JavaScript haladó - Objektum Orientált Programozás',
        header2:    'This 2 / 4',
        question:   'Mi lesz a this értéke a függvényen belül, amikor meghívjuk? (A globális környezetben vagyunk)<br><br>&emsp; function myFunction() {<br>&emsp; &emsp; return this;<br>&emsp; }<br><br>&emsp; myFunction();<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['A function',
                    'A Window object',
                    'null',
                    'undefined'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Strict mód nélkül, globális kódban elhelyezett függvény esetében mindig a globális Window object.'
    },
    {
        header1:    '5. JavaScript haladó - Objektum Orientált Programozás',
        header2:    'This 3 / 4',
        question:   'Mi lesz a konzolon az alábbi kód lefutása után?<br><br>&emsp; \'use strict\';<br><br>&emsp; const user = {<br>&emsp; &emsp; name: \'John\',<br>&emsp; &emsp; myNameIs() {<br>&emsp; &emsp; &emsp; console.log(this.name);<br>&emsp; &emsp; }<br>&emsp; };<br><br>&emsp; const data = {<br>&emsp; &emsp; name: \'Jane\',<br>&emsp; }<br><br>&emsp; const person = user.myNameIs;<br>&emsp; person.call(data);<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Jane',
                    'John',
                    'Window object',
                    'undefined'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'A person-nak átadom a myNameIs metódus referenciáját.<br>Meghívom ezt a call-lal, a this értéknek a data-t adom meg, tehát a name értéke Jane lesz. Ez lesz a logon.'
    },
    {
        header1:    '5. JavaScript haladó - Objektum Orientált Programozás',
        header2:    'This 4 / 4',
        question:   'Mi lesz a konzolon, miután rákattintok a gombra? (A gomb a DOM része)<br><br>&emsp; document.body.insertAdjacentHTML(<br>&emsp; &emsp; \'afterend\', <br>&emsp; &emsp; \'<<span style="font-size: 0rem;"> </span>button onclick="console.log(this)">Click me<<span style="font-size: 0rem;"> </span>/button>\'<br>&emsp; );<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['A Window object',
                    'A Button element',
                    'Az Event object',
                    'undefined'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Az onclick attributumnál hívjuk meg a console.log() metódust.<br>Az Event a gombon következett be, a this maga a button lesz.'
    },
    // 5. JS - Objektumok – haladó
    {
        header1:    '5. JavaScript haladó - Objektum Orientált Programozás',
        header2:    'Objektumok – haladó 1 / 2',
        question:   'Az alábbiak közül melyik nem egy property descriptor?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['enumerable',
                    'configurable',
                    'writable',
                    'readable'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'writable: módosítható-e vagy sem<br>configurable: törölhető-e<br>enumerable: felsorolható-e'
    },
    {
        header1:    '5. JavaScript haladó - Objektum Orientált Programozás',
        header2:    'Objektumok – haladó 2 / 2',
        question:   'Minek van prototype tulajdonsága?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['minden objektumnak',
                    'minden függvénynek',
                    'minden primitívnek',
                    'minden objektumnak, ami nem függvény'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Függvénynek prototype tulajdonsága van, az objecteknek (minden típusú objectnek a függvényeket is beleértve), pedig [[Prototype]] (is).'
    },
    // 5. JS - OOP
    {
        header1:    '5. JavaScript haladó - Objektum Orientált Programozás',
        header2:    'OOP 1 / 3',
        question:   'Mikor fut le a konstruktor függvény?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['a class létrehozásakor',
                    'objektumpéldány létrehozásakor',
                    'amikor manuálisan meghívom',
                    'exportáláskor'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'MDN-ről idézve: "The constructor method is a special method of a class for creating and initializing an object of that class." Tehát objektum létrehozásakor fut le.'
    },
    {
        header1:    '5. JavaScript haladó - Objektum Orientált Programozás',
        header2:    'OOP 2 / 3',
        question:   'Mi lesz a kimeneten?<br>&emsp; class User {<br><br>&emsp; &emsp; static speak(message) {<br>&emsp; &emsp; &emsp; return `User says: ${message}`<br>&emsp; &emsp; }<br>&emsp; }<br><br>&emsp; console.log(User.speak(\'hi\')<br><br>Válaszd ki az EGYETLEN megfelelő választ!', 
        options:    ['User says: hi',
                    'User says: undefined',
                    'hi',
                    'Error, mert nincs példányosítás'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'Egy darab statikus metódusunk van, amit mindig példányosítás nélkül kell meghívni, mert a statikus metódusok csak classen keresztül érhetők el, a példányokon keresztül nem. Jelen esetben a User.speak metódusa visszaadja  a User says: literált összefűzve a pareméterként átadott értékkel.'
    },
    {
        header1:    '5. JavaScript haladó - Objektum Orientált Programozás',
        header2:    'OOP 3 / 3',
        question:   'Lehetséges egy gyermekosztályban felülírni egy szölőosztályban definiált metódust?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['igen',
                    'nem',
                    'csak a gettert/settert',
                    'csak ha a szülőben volt constructor'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'Semmi akadálya az overriding-nek.'
    },
    // 5. JS - Záró Kvíz
    {
        header1:    'JavaScript haladó',
        header2:    'Záró Kvíz 1 / 10',
        question:   'Hol tárolnád a biztonsági szempontból érzékeny adatokat kliensoldalon?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['localStorage-ban',
                    'sessionStorage-ban',
                    'httpOnly secure cookie-ban',
                    'JavaScript konstansban'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'A httpOnly secure cookie-t nem lehet JavaScriptből módosítani, így ez a legjobb megoldás. Http header-ben található.'
    },
    {
        header1:    'JavaScript haladó',
        header2:    'Záró Kvíz 2 / 10',
        question:   'Több aszinkron kérést kell elindítani egyszerre, és meg kell várni, míg mindegyik fulfilled lesz. Melyik Promise metódust használnád?<br><br>Válaszd ki az EGYETLEN megfelelő választ!', 
        options:    ['all()',
                    'race()',
                    'allSettled()',
                    'any()'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     ''
    },
    {
        header1:    'JavaScript haladó',
        header2:    'Záró Kvíz 3 / 10',
        question:   'Melyik összetett adatszerkezetet kell használni, ha nem akarod, hogy duplikált elemek forduljanak elő benne?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Array',
                    'Map',
                    'Set',
                    'WeakMap'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'Set-be nem fognak belekerülni a duplikált elemek. Array, Map, WeakMap esetében lehetnek duplikált elemek.'
    },
    {
        header1:    'JavaScript haladó',
        header2:    'Záró Kvíz 4 / 10',
        question:   'Válaszd ki a helyes állítást! Minden objektum rendelkezik:<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['prototype tulajdonsággal',
                    'egy belső [[Prototpye]] tulajdonsággal',
                    'PROTO tulajdonsággal',
                    'egyik sem igaz'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'prototype tulajdonsággal csak a függvények rendelkeznek, [[Prototype]]-pal pedig minden egyes objektum. PROTO így negybetűkkel nem létezik. __proto__ van, ami egy getter/setter a [[Prototype]]-ra. '
    },
    {
        header1:    'JavaScript haladó',
        header2:    'Záró Kvíz 5 / 10',
        question:   'Adott az alábbi kód:<br><br>&emsp; const arr = [1, 2, 3, 4, 5];<br>&emsp; const i = 2;<br>&emsp; [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];<br><br>Mi lesz az arr[i] és az arr[i+1] értéke?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['2, 3',
                    '3, 2',
                    '3, 4',
                    '4, 3'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'Két értéket felcserélünk egymással. Egy tipikus példája a destructuringnak.'
    },
    {
        header1:    'JavaScript haladó',
        header2:    'Záró Kvíz 6 / 10',
        question:   'Az alábbiak közül melyik nem egy Promise állapota?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['pending',
                    'fulfilled',
                    'catched',
                    'rejected'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'A promise az alábbi állapotokkal rendelkezhet: pending, fulfilled, rejected, illetve settled (ha fulfilled vagy rejected, de nem pending).'
    },
    {
        header1:    'JavaScript haladó',
        header2:    'Záró Kvíz 7 / 10',
        question:   'Mi lesz az alábbi kód visszatérési értéke?<br><br>&emsp; [1, 2, 3, 4, 5]<br>&emsp; &emsp; .filter(item => item ** 2 % 3)<br>&emsp; &emsp; .reduce((previous, current) => previous + current);<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['5',
                    '12',
                    '14',
                    '7'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Négyzetre emeljük az elemeket, majd maradékosan elosztjuk 3-mal, amennyiben itt a kiértékelés után true-t kapunk, visszaadjuk az eredeti elemet. A filternél egyedül itt lesz az érték 0, ami false-ra értékelődik ki: 3 ** 2 % 3. Tehát a filter után a tömbünk: [1, 2, 4, 5] Ezután ezeket az értékeket összeadjuk: 12'
    },
    {
        header1:    'JavaScript haladó',
        header2:    'Záró Kvíz 8 / 10',
        question:   'A következő kód esetében mi lesz a “b” változó típusa?<br><br>&emsp; const arr = [undefined, \'\', , \'two\', \'three\', \'four\'];<br>&emsp; const [a, b, c, d] = arr;<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['undefined',
                    'null',
                    'string',
                    'empty'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'A “b” az “arr” tömb 2 elemének az értékét veszi fel, ami egy üres string. Attól, hogy üres, még string marad.'
    },
    {
        header1:    'JavaScript haladó',
        header2:    'Záró Kvíz 9 / 10',
        question:   'Mi a különbség a call() és az apply() metódusok között?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['a call() a this után felsorolva várja a paramétereket, az apply() tömbösítve',
                    'semmi',
                    'az apply() a this után felsorolva várja a paramétereket, a call() tömb szinten',
                    'a call() új függvényt hoz létre, az apply() csak meghívja azt, beállítva a this értékét'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'A call() felsorolva, az apply() tömbösítve várja a paramétereket a this után.'
    },
    {
        header1:    'JavaScript haladó',
        header2:    'Záró Kvíz 10 / 10',
        question:   'Az alábbi minta melyik stringre fog illeszkedni?<br><br>&emsp; /^(\\d{3} ){2}\\d{3}$/<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ["'111 222 333'",
                    "'ABC BCD'",
                    "'ABC BCD CDE'",
                    "'111222333'"],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     '^( ): kezdődjön három darab számmal, majd utána legyen egy szóköz<br>{2}: Az előző ismétlődjön kétszer<br>$: majd legyen még 3 darab szám, és itt vége is a stringnek'
    },
    // Vegyes Gyakorló Kvíz
    {
        header1:    'Vegyes',
        header2:    'Gyakorló Kvíz 1 / 20',
        question:   'Elérhető az i változó a ciklus után?<br><br>&emsp; for (let i = 0; i < 2; i++) {<br>&emsp; &emsp; console.log(i);<br>&emsp; }<br>&emsp; console.log(i);<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Nem.',
                    'Nem, mert function scope-ú.',
                    'Igen',
                    'Igen, mert lehet módosítani az értékét.'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'Az i ebben az esetben csak a ciklusban érhető el, mert block-scoped, azaz a {} jelek között él.'
    },
    {
        header1:    'Vegyes',
        header2:    'Gyakorló Kvíz 2 / 20',
        question:   'Miért a [6] lesz a kimenete az alábbi kódnak?<br><br>&emsp; console.log( [1, 3, 5, 6, 7].filter( num => num % 2 === 0 ) );<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Mert a szűrésnél a 6 az egyetlen szám, ami 2-vel osztva 0 maradékot ad.',
                    'Mert a 6 a negyedik eleme a tömbnek.',
                    'Mert ha megszorzom 2-vel a hatot és osztom nullával, akkor 1 marad.',
                    'Mert a 6 a 3-mas indexű eleme az eredeti tömbnek, és a filter mindig azt adja vissza.'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'A filter úgy működik, hogy azt a számot adja vissza, ami 2-vel osztva 0 maradékot ad.'
    },
    {
        header1:    'Vegyes',
        header2:    'Gyakorló Kvíz 3 / 20',
        question:   'Melyik elem self-closed elem az alábbiak közül?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['input',
                    'span',
                    'h2',
                    'form'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'Az input self-closed elem.'
    },
    {
        header1:    'Vegyes',
        header2:    'Gyakorló Kvíz 4 / 20',
        question:   'Melyik scss változó van létrehozva helyesen?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['$primary-color: #333;',
                    '#primary-color: #333;',
                    '~primary-color: #333;',
                    '$primary-color: 333;'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'Mindig $ jellel kezdünk és a hexadecimális színek elé # jelet teszünk.'
    },
    {
        header1:    'Vegyes',
        header2:    'Gyakorló Kvíz 5 / 20',
        question:   'Melyik két technológiára lesz szükségem, ha az alábbi gombokat szeretném megjeleníteni?<br><br>&emsp; < div class="btn-group" > <br>&emsp; &emsp; < button class="btn btn-info" > <br>&emsp; &emsp; &emsp;  < i class="fa fa-eye" > < / i > <br>&emsp; &emsp; < / button > <br>&emsp; &emsp; < button class="btn btn-danger" > <br>&emsp; &emsp; &emsp; < i class="fa fa-trash" > < / i > <br>&emsp; &emsp; < / button > <br>&emsp; < / div > <br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['bootstrap font-awesome',
                    'bootstrap angular',
                    'angular json-server',
                    'jquery angular'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'A gombok formázásához bootstrap, az ikonokhoz font-awesome kell.'
    },
    {
        header1:    'Vegyes',
        header2:    'Gyakorló Kvíz 6 / 20',
        question:   'Melyik Bootstrap osztállyal tudok az alábbi div-nek 3em jobb margót adni?<br><br>&emsp; < div class="btn-group" > < / div > <br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['mr-3',
                    'mt-3',
                    'mb-3',
                    'margin-right-3'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'Az mr osztályok állítanak be jobb margót.'
    },
    {
        header1:    'Vegyes',
        header2:    'Gyakorló Kvíz 7 / 20',
        question:   'Miben különbözik az arrow function a hagyományos JAVASCRIPT függvényektől?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Nem bindolja a thist.',
                    'Bindolja a thist.',
                    'Thiseli a bindot.',
                    'Semmiben.'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'Nem bindolja, azaz nem köti a this-t. Ennek következtében például eseményeknél nem változik meg a this értéke.'
    },
    {
        header1:    'Vegyes',
        header2:    'Gyakorló Kvíz 8 / 20',
        question:   'Miért \'hello\' lesz a kimenete az alábbi kódnak?<br><br>&emsp; var message = \'hello\';<br>&emsp; const test = () => {<br>&emsp; &emsp; const message = \'hello\';<br>&emsp; &emsp; console.log(this.message);<br>&emsp; }<br>&emsp; test();<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Mert a var kulcsszó a window-hoz köti a message változót.',
                    'Mert a függvény a const message tartalmát írja ki.',
                    'Mert az arrow function bindolja a this-t.',
                    'Mert a két változó egyforma értékű, ezért mindegy melyiket írja ki a függvény, és úgy döntött, hogy inkább a lokálist írja ki.'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'Az arrow function-on belül a window a this, és a var kulcsszóval létrehozott változó a window változója lesz.'
    },
    {
        header1:    'Vegyes',
        header2:    'Gyakorló Kvíz 9 / 20',
        question:   'Az alábbi bootstrap-pel formázott HTML kód hatására hány kártya lesz egymás mellett az első sorban mobil nézetben?<br><br>&emsp; < div class="row" > <br>&emsp; &emsp; < div class="card col-4" > < / div > <br>&emsp; &emsp; < div class="card col-4" > < / div > <br>&emsp; &emsp; < div class="card col-2" > < / div > <br>&emsp; &emsp; < div class="card col-4" > < / div > <br>&emsp; &emsp; < div class="card col-4" > < / div > <br>&emsp; < / div > <br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['3',
                    '4',
                    '2',
                    '5'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'A 12 oszlop miatt 3 fér ki, 4 + 4 + 2, a következő 4 már nem.'
    },
    {
        header1:    'Vegyes',
        header2:    'Gyakorló Kvíz 10 / 20',
        question:   'Mi lesz a user értéke a művelet után?<br><br>&emsp; let user = {name: \'Pisti\'};<br>&emsp; user = ({...user, id: 4});<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['{id: 4, name: \'Pisti\'}',
                    '{name: \'Pisti\'}',
                    '{id: 4}',
                    '{id: 4, name: \'Sándor\'}'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     ''
    },
    {
        header1:    'Vegyes',
        header2:    'Gyakorló Kvíz 11 / 20',
        question:   'Hány h1 tag lehet egy html oldalon belül?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['1',
                    'akármennyi',
                    'ahány article tag',
                    'ahány header tag'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'A h1 elemek száma nem függ sem az article, sem a header tag-ektől. Egy oldalon akármennyi lehet.'
    },
    {
        header1:    'Vegyes',
        header2:    'Gyakorló Kvíz 12 / 20',
        question:   'Mit használnál abban az esetben, ha különböző breakpoint-oknál más-más képet kellene betölteni? A lehető leghatékonyabb és hibatűrő megoldást kell választani!<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['az img tag srcset tulajdonságát adnám meg',
                    'a picture taget használnám',
                    'Javascript-tel figyelném a screen-t és az img tag src tulajdonságát dinamikusan módosítanám',
                    'css background image-et használnék és media query-ket'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Amennyiben egy adott kép különböző részleteit akarjuk használni, vagy eltérő képeket különböző töréspontokon, a picture tag a legszerencsésebb választás. Az src-set-et akkor érdemes használni, ha ugyanazon kép más méretű verzióira van szükségünk.'
    },
    {
        header1:    'Vegyes',
        header2:    'Gyakorló Kvíz 13 / 20',
        question:   'Melyik két css tulajdonság megadásával tudom egy flex div-en belül az elemeket mind vertikálisan, mind horizontálisan középre igazítani?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['align-items, text-align',
                    'position, text-align',
                    'align-items, justify-content',
                    'text-align, justify-content'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'Flex típusú elemnél a horizontális és a vertikális pozícionálást mindig ezen két tulajdonsággal oldjuk meg.'
    },
    {
        header1:    'Vegyes',
        header2:    'Gyakorló Kvíz 14 / 20',
        question:   'A html elemnél a font size: 16px. Hány pixel széles lesz a bal oldali margó egy elemnél, ha az alábbi CSS kódot látjuk:<br><br>&emsp; margin: 1rem .25rem .5rem;<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['4',
                    '8',
                    '16',
                    '2'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'A margó értékek: felső, jobb-bal, alsó<br>A 16px-nek a negyede 4px.'
    },
    {
        header1:    'Vegyes',
        header2:    'Gyakorló Kvíz 15 / 20',
        question:   'Mi lesz a num értéke?<br><br>&emsp; function fn(a) {<br>&emsp; &emsp; if (arguments.length == 2) {<br>&emsp; &emsp; &emsp; return arguments[0] + arguments[1];<br>&emsp; &emsp; } else {<br>&emsp; &emsp; &emsp; return function(b) { return a + b; };<br>&emsp; &emsp; }<br>&emsp; }<br>&emsp; const num = fn(2)(3)<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['2',
                    '3',
                    '5',
                    '6'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'Egyszerűen csak meghívtuk a visszatérési értékként megadott függvényt is.<br>2 + 3 = 5'
    },
    {
        header1:    'Vegyes',
        header2:    'Gyakorló Kvíz 16 / 20',
        question:   'Mi lesz az alábbi művelet eredménye?<br>{} === {}<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['true',
                    'false',
                    'hibát dob',
                    'undefined'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Két objektum sosem lesz egyenlő. Más memóriaterületen vannak.'
    },
    {
        header1:    'Vegyes',
        header2:    'Gyakorló Kvíz 17 / 20',
        question:   'Hány elemű lesz a filter metódus által visszaadott tömb?<br><br>&emsp; [NaN, null, undefined, \'\', 0, false, {}].filter(item => item)<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['7',
                    '6',
                    '4',
                    '1'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'A NaN, null, undefined, \'\', 0, false értékek feltételvizsgálatban mindig false-t adnak. Minden objektum, még ha üres is, true-t. Tehát egyedül az üres objektum lesz a tömbben.'
    },
    {
        header1:    'Vegyes',
        header2:    'Gyakorló Kvíz 18 / 20',
        question:   'Mennyi lesz a tömb hossza?<br><br>&emsp; const clothes = [\'jacket\', \'t-shirt\'];<br>&emsp; clothes.length = 0;<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['0',
                    '1',
                    '2',
                    '3'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'Mivel beállítottuk 0-ra, ezzel törölve az elemeket, ezért a hossz 0 lesz.'
    },
    {
        header1:    'Vegyes',
        header2:    'Gyakorló Kvíz 19 / 20',
        question:   'Mi lesz a konzolon az alábbi kód lefutása után?<br><br>&emsp; const user = {<br>&emsp; &emsp; name: "John",<br>&emsp; &emsp; getName(){<br>&emsp; &emsp; &emsp; return this.name;<br>&emsp; &emsp; },<br>&emsp; };<br>&emsp; var name = "Jane";<br>&emsp; const getUserName = user.getName;<br>&emsp; console.log(getUserName());<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Jane',
                    'John',
                    'Error',
                    'undefined'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'A user objektum getName metódusát kimentettük egy külön változóba, ami a globális környezetben van. Ha ezt meghívom, a this a globális this, tehát a Window object. A var-ral létrehozott változók a Window property-jeként megjelennek. Mivel a name változó értéke "Jane", ez lesz a konzolon.'
    },
    {
        header1:    'Vegyes',
        header2:    'Gyakorló Kvíz 20 / 20',
        question:   'JavaScriptben minek van [[Prototype]] tulajdonsága?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Minden function-nek',
                    'Minden Object objektumnak',
                    'Semminek',
                    'Minden egyes objektumnak'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'Belső [[Prototype]] tulajdonsága minden objektumnak van. Nem összekeverendő a prototype-pal, ami a függvényeknek van.'
    },
    // JavaScript 1. részvizsgából
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 1 / 30',
        question:   'Adott a következő tömb:<br><br>&emsp; const arr = [34, 65, 78, 99, 212, 1001];<br><br>Ebben a tömbben keresem a 78-as értéket. Hányszor fog a lineáris keresési algoritmus esetén, és hányszor a logaritmikus keresési algoritmus esetén lefutni a belső ciklus?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['6, 1',
                    '6, 3',
                    '3, 3',
                    '3, 1'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 2 / 30',
        question:   'Az alábbi kód futtatása során mi lesz a konzolon?<br><br>&emsp; fnDeclaration();<br>&emsp; fnExpr();<br><br>&emsp; function fnDeclaration() {<br>&emsp; &emsp; console.log(\'fnDec\');<br>&emsp; }<br><br>&emsp; var fnExpr = () => {<br>&emsp; &emsp; console.log(\'fnExp\')<br>&emsp; }<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['fnDec, fnExp',
                    'fnDec, TypeError',
                    'fnDec, ReferenceError',
                    'fnDec, undefined'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 3 / 30',
        question:   'Mi lesz az arr tömb tartalma a kód lefutása után?<br><br>&emsp; const arr = [1, 2, 3];<br>&emsp; arr.splice(1, 0, 4);<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['[1, 4, 2, 3]',
                    '[1, 2, 4]',
                    '[1, 2, 3, 4]',
                    '[1, 2, 3]'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 4 / 30',
        question:   'Az alábbi függvény növekvő vagy csökkenő sorrendbe rendezi az elemeket?<br><br>&emsp; function bubbleSort(arr) {<br>&emsp; &emsp; let swapped;<br>&emsp; &emsp; do {<br>&emsp; &emsp; &emsp; swapped = false;<br>&emsp; &emsp; &emsp; for (let i = 0; i < arr.length -1; i += 1) {<br>&emsp; &emsp; &emsp; &emsp; if (arr[i] > arr[i + 1]) {<br>&emsp; &emsp; &emsp; &emsp; &emsp; let temp = arr[i];<br>&emsp; &emsp; &emsp; &emsp; &emsp; arr[i] = arr[i + 1];<br>&emsp; &emsp; &emsp; &emsp; &emsp; arr[i + 1] = temp;<br>&emsp; &emsp; &emsp; &emsp; &emsp; swapped = true;<br>&emsp; &emsp; &emsp; &emsp; }<br>&emsp; &emsp; &emsp; }<br>&emsp; &emsp; } while (swapped)<br>&emsp; &emsp; return arr;<br>&emsp; }<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['csökkenő',
                    'növekvő',
                    'nem fog rendezni',
                    'Error-t fog dobni'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 5 / 30',
        question:   'Melyik kulcsszóval létrehozott változók esetében van hoisting?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['var',
                    'var, let, const',
                    'let, const',
                    'egyiknél sincs'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 6 / 30',
        question:   'Melyik kulcsszóval létrehozott változó esetében kell rögtön deklarációt is alkalmazni?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['var',
                    'let',
                    'const',
                    'egyiknél sem kell'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 7 / 30',
        question:   'Az alábbiak közül melyik állítás igaz a függvényekre?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Nem lehet másik függvény visszatérési értéke.',
                    'Nem adhatjuk át paraméterként egy másik függvénynek.',
                    'Nem rendelhetjük hozzá változóhoz.',
                    'Egyik sem igaz.'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 8 / 30',
        question:   'Hányszor fog lefutni a ciklusmag?<br><br>&emsp; const arr = [1, 2, 3, 4, 5]<br>&emsp; arr[1000] = 1000;<br>&emsp; for (const key in arr) {<br>&emsp; &emsp; if (arr.hasOwnProperty(key)) {<br>&emsp; &emsp; &emsp; console.log(arr[key]);<br>&emsp; &emsp; }<br>&emsp; }<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['5',
                    '6',
                    '1000',
                    '1001'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 9 / 30',
        question:   'Mire példa az alábbi kód?<br><br>&emsp; (function() {<br>&emsp; &emsp; console.log(\'example\')<br>&emsp; })()<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['IIFE',
                    'callback',
                    'closure',
                    'arrow function'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 10 / 30',
        question:   'Az alábbiak közül melyik NEM egy primitív típus?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['number',
                    'string',
                    'array',
                    'undefined'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 11 / 30',
        question:   'Mi lesz a konzolon az alábbi kód lefutása után?<br><br>&emsp; console.log(firstName);<br>&emsp; var firstName = \'John\';<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['\'John\'',
                    'ReferenceError',
                    'TypeError',
                    'undefined'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 12 / 30',
        question:   'Mi lesz a konzolon az alábbi kód lefutása után?<br><br>&emsp; console.log(firstName);<br>&emsp; const firstName = \'John\';<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['\'John\'',
                    'ReferenceError',
                    'TypeError',
                    'undefined'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 13 / 30',
        question:   'Mi lesz a konzolon az alábbi kód lefutása után?<br><br>&emsp; console.log(firstName);<br>&emsp; const firstName;<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['SyntaxError',
                    'ReferenceError',
                    'TypeError',
                    'undefined'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 14 / 30',
        question:   'Mi lesz a konzolon az alábbi kód lefutása után?<br><br>&emsp; console.log(firstName);<br>&emsp; let firstName;<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['SyntaxError',
                    'ReferenceError',
                    'TypeError',
                    'undefined'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 15 / 30',
        question:   'Mi lesz a függvény visszatérési értéke?<br><br>&emsp; function logger(data) {<br>&emsp; &emsp; return<br>&emsp; &emsp; &emsp; \'log\' + data;<br>&emsp; }<br>&emsp; logger(\'error\');<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['\'logerror\'',
                    'null',
                    'undefined',
                    'Hibát fog dobni'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 16 / 30',
        question:   'Az alábbi feltételvizsgálatok milyen értéket adnak vissza?<br><br>&emsp; 1 == \'1\'<br>&emsp; 1 === \'1\'<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['true, true',
                    'true, false',
                    'false, true',
                    'false, false'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 17 / 30',
        question:   'Milyen típusú a typeof visszatérési értéke?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['string',
                    'number',
                    'boolean',
                    'type'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 18 / 30',
        question:   'Melyik nevezetes algoritmus kódját reprezentálja az alábbi kód?<br><br>&emsp; function algo(arr) {<br>&emsp; &emsp; let value = arr[0];<br>&emsp; &emsp; for (let i = 1; i < arr.length; i += 1) {<br>&emsp; &emsp; &emsp; if (arr[i] < value) {<br>&emsp; &emsp; &emsp; &emsp; value = arr[i];<br>&emsp; &emsp; &emsp; }<br>&emsp; &emsp; }<br>&emsp; &emsp; return value;<br>&emsp; }<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['összegzés',
                    'számlálás',
                    'minimum kiválasztás',
                    'maximum kiválasztás'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 19 / 30',
        question:   'Megírtad a bináris keresés algoritmust, de valamiért nem jól működik. Mi a baj?<br><br>&emsp; function binarySearch(arr, search) {<br>&emsp; &emsp; let start = 0;<br>&emsp; &emsp; let end = arr.length - 1;<br>&emsp; &emsp; while (start <= end) {<br>&emsp; &emsp; &emsp; const mid = Math.floor((start + end) / 2);<br>&emsp; &emsp; &emsp; if (arr[mid] === search) {<br>&emsp; &emsp; &emsp; &emsp; return true;<br>&emsp; &emsp; &emsp; }<br>&emsp; &emsp; &emsp; else if (arr[mid] > search) {<br>&emsp; &emsp; &emsp; &emsp; start = mid + 1;<br>&emsp; &emsp; &emsp; }<br>&emsp; &emsp; &emsp; else {<br>&emsp; &emsp; &emsp; &emsp; end = mid - 1;<br>&emsp; &emsp; &emsp; }<br>&emsp; &emsp; }<br>&emsp; &emsp; return false;<br>&emsp; }<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['A const mid = Math.floor((start + end) / 2) sorban nem const, hanem let kell.',
                    'Az arr[mid] > search kódrészletnél rossz a relációs jel.',
                    'A két visszatérési értéket meg kell cserélni.',
                    'Nincs semmi gond a kóddal.'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 20 / 30',
        question:   'Melyik állítás igaz a tömbökre JavaScript-ben?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['A tömb mindig szekvenciális, azaz folyamatos.',
                    'Csak adott típusú elemeket tartalmazhat.',
                    'Maximum 128 eleme lehet.',
                    'Egyik állítás sem igaz.'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 21 / 30',
        question:   'Mi lesz a konzolon az alábbi kód lefutása után?<br><br>&emsp; const grade = 3;<br>&emsp; switch (grade) {<br>&emsp; &emsp; case 1:<br>&emsp; &emsp; &emsp; console.log(\'Elégtelen\');<br>&emsp; &emsp; case 2:<br>&emsp; &emsp; &emsp; console.log(\'Elégséges\');<br>&emsp; &emsp; case 3:<br>&emsp; &emsp; &emsp; console.log(\'Közepes\');<br>&emsp; &emsp; case 4:<br>&emsp; &emsp; &emsp; console.log(\'Jó\');<br>&emsp; &emsp; case 5:<br>&emsp; &emsp; &emsp; console.log(\'Jeles\');<br>&emsp; &emsp; default:<br>&emsp; &emsp; &emsp; console.log(\'Ez nem osztályzat\');<br>&emsp; }<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Közepes',
                    'Ez nem osztályzat',
                    'Közepes, Jó, Jeles',
                    'Közepes, Jó, Jeles, Ez nem osztályzat'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 22 / 30',
        question:   'Mi lesz a függvény visszatérési értéke?<br><br>&emsp; function sample() {<br>&emsp; &emsp; console.log(true);<br>&emsp; }<br><br>&emsp; sample();<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['true',
                    'false',
                    'undefined',
                    'Error-t fog dobni'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 23 / 30',
        question:   'Mi lesz a person értéke a kód lefutása után?<br><br>&emsp; const person = {<br>&emsp; &emsp; firstName: \'John\',<br>&emsp; &emsp; lastName: \'Doe\'<br>&emsp; };<br><br>&emsp; person.firstName = \'Jane\';<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['{ firstName: \'John\', lastName: \'Doe\' };',
                    '{ firstName: \'Jane\', lastName: \'Doe\' };',
                    '\'Jane\'',
                    'Error-t fog dobni'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 24 / 30',
        question:   'Mi lesz a person értéke a kód lefutása után?<br><br>&emsp; const person = {<br>&emsp; &emsp; firstName: \'John\',<br>&emsp; &emsp; lastName: \'Doe\'<br>&emsp; };<br><br>&emsp; person = {<br>&emsp; &emsp; firstName: \'Jane\',<br>&emsp; &emsp; lastName: \'Doe\'<br>&emsp; };<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['{ firstName: \'John\', lastName: \'Doe\' };',
                    '{ firstName: \'Jane\', lastName: \'Doe\' };',
                    '\'Jane\'',
                    'Error-t fog dobni'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 25 / 30',
        question:   'Mikor ad a JavaScript null értéket egy változónak?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['var kulcsszóval létrehozott változónak, ha nem adunk meg értéket',
                    'Függvény visszatérési értékének, ha nem használunk return kulcsszót',
                    'Függvény visszatérési értékének, ha nem adunk meg értéket a return kulcsszó után',
                    'Csak akkor, ha manuálisan rendeljük hozzá a null-t egy változóhoz'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 26 / 30',
        question:   'Min tudok végigiterálni a for in ciklus segítségével?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Objektum tulajdonságain (azaz a property name-eken)',
                    'Objektum tulajdonságainak az értékén',
                    'Tömb elemein (azaz az értékeken)',
                    'Semmin'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 27 / 30',
        question:   'Valid az alábbi for header? Ha nem, miért nem, ha igen, miért igen?<br><br>&emsp; for(;;) {<br><br>&emsp; }<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Igen, ez egy végtelen ciklus.',
                    'Igen, de soha nem lép be a ciklusmagba.',
                    'Nem, szintaktikailag hibás.',
                    'Nem, mert üres a ciklusmag.'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 28 / 30',
        question:   'Mi lesz az arr tömb tartalma a kód futása után?<br><br>&emsp; const arr = [435, 567, 8, 435, 345, 677];<br>&emsp; arr.splice(0, 0, 0);<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['[]',
                    '[0]',
                    '[0, 435, 567, 8, 435, 345, 677]',
                    '[435, 567, 8, 435, 345, 677]'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 29 / 30',
        question:   'Mi lesz az arr1 tartalma?<br><br>&emsp; const arr1 = [1, 2, 3];<br>&emsp; const arr2 = arr1;<br>&emsp; arr2.push(4);<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['[1, 2, 3]',
                    '4',
                    '[4]',
                    '[1, 2, 3, 4]'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     ''
    },
    {
        header1:    'JavaScript',
        header2:    '1. részvizsga 30 / 30',
        question:   'Melyik állítások igazak a let és const kulcsszóval deklarált változókra?<br><br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['nem lehet őket újradeklarálni',
                    'lokális hatókörűek',
                    'inicializálás előtt elérhetőek',
                    'nem lehet újra inicializálni őket'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     ''
    },
];